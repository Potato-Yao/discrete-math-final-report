\chapter{The Complexity and Security Analysis of RSA Algorithm}

The trapdoor function of RSA algorithm is the modular exponentiation operation.
It is a one-way function that is easy to compute but hard to invert, 
and this ensures the security of RSA algorithm.


\section{Time Complexity Analysis}

\subsection{Select Primes}

  If we randomly select $p$ and $q$, and check if they are prime,
  according to prime density theorem, the expected selection rounds is $O(\ln n)$.
  So, when using Miller-Rabin test to check if $p$ and $q$ are prime,
  the time complexity of this step is $O(k (\ln n)^4)$, 
  where $k$ is the test rounds for a single number in Miller-Rabin test.
  
  Optimizations using FFT can reduce the time complexity of Miller-Rabin test to \\ $O(k(\ln n)^2 \ln \ln n \ln \ln \ln n)$,
  but it's usually not the first choice in practice.

\subsection{Compute Modulus and Totient}

  The time complexity of computing product of two integers is $O((\ln n)^2)$.
  So, the time complexity of computing $n$ and $\varphi(n)$ is $O((\ln n)^2)$.

\subsection{Choose Public Exponent}

  We can arbitrarily select a prime number $e$ while ensuring $e \perp \varphi(n)$.
  If we use Euclidean Algorithm to calculate $\gcd(e, \varphi(n))$,
  the time complexity of this step is $O((\ln n)^2)$.

  \begin{proof}
    First, $e$ and $\varphi(n)$ both have $O(\ln n)$ bits. 
    The Euclidean Algorithm process requires $k = O(\ln n)$ steps,
    so the time complexity seems to be $O((\ln n)^3)$, since each step 
    requires $O((\ln n)^2)$ time to calculate the remainder.
    
    Let $(a_{i - 1}, a_i)$ be the numbers in the $i$-th step of Euclidean Algorithm ($a_{i - 1} \ge a_i$), 
    $l_i$ be the length of bits of $a_i$ in decimal.
    Here, we have $a_0 = \max(e, \varphi(n)), a_1 = \min(e, \varphi(n))$.

    Let $q_i = \lfloor \dfrac{a_{i - 1}}{a_{i}} \rfloor$, 
    the length of $q_i$ in decimal is at most $l_{i - 1} - l_i + 1$. 
    So, the process to calculate the remainder in each step is $O(l_i(l_{i - 1} - l_i + 1))$.

    We have $l_{i - 1} \ge l_i$, so $l_i(l_{i - 1} - l_i + 1) \le l_{i - 1}(l_{i - 1} - l_i + 1)$.
    Ignoring the coefficient, then we have
    $$
      \begin{aligned}
        \sum_{i = 1}^{k} l_{i}(l_{i - 1} - l_i) \le \sum_{i = 1}^{k} l_{i - 1}(l_{i - 1} - l_i) 
        \le \int_{0}^{l_0} x \text{d} x = \dfrac{l_0^2}{2} = O((\ln n)^2)
      \end{aligned}
    $$
    Therefore, the time complexity of calculating $\gcd(e, \varphi(n))$ is $O((\ln n)^2)$ instead of $O((\ln n)^3)$.
  \end{proof}

\subsection{Compute Private Exponent}

  The time complexity of computing $d$ is also $O((\ln n)^2)$ using Extended Euclidean Algorithm.

\subsection{Summary}

  To sum up, the time complexity of RSA encryption is $O((\ln n)^4)$
   (ignoring coefficient $k$ in Miller-Rabin test), 
  which is of polynomial time.
  However, we'll discuss that the time complexity of classical deciphering attacks is of exponential time,
  which is much slower than encryption process.

\section{Security Analysis}

Deciphering process of RSA algorithm is polynomial-time equivalent to large integer factorization problem
and high power residue problem in classical computing theory, 
which are both speculated to be NP-intermediate.
In the following sections, we will discuss some deciphering methods 
that are used to break RSA algorithm.


\subsection{Try All Possible Values of $d$}

  In this method, attackers try all possible values of $d$ until 
  they find the correct one. The worst case time complexity of this attack is $O(n)$, 
  which is definitely infeasible for large $n$.

\subsection{Brute Force to Factor $n$}
	      
  Enumerate all integers $p$ in $[2, \sqrt n]$, and check if $n$ is divisible by $p$.
  The time complexity of this attack is $O(\sqrt n)$.

\subsection{Factor $n$ by Pollard's Rho plus ECM Algorithm}
	      
  Pollard's Rho Algorithm is based on Birthday Paradox, 
  and can factorize an integer $n$ with an expected 
  time complexity of $O(\sqrt p)$, where $p$ is the smallest prime factor of $n$.
  This algorithm is widely used to decipher RSA ciphertext 
  when $p$ and $q$ are both less than $128$ bits in decimal.

  ECM (Elliptic Curve Method) was proposed by Hendrik Lenstra in 1985.
  This algorithm extends Pollard's $p - 1$ Algorithm to elliptic curve groups, 
  optimizing the efficiency based on the group order changes caused by parameter variations.
  The time complexity of ECM Algorithm is $L_p[\dfrac{1}{2}, \sqrt 2]$, where
  $$
  L_x[a, b] = e^{b (\ln x)^a (\ln \ln x)^{1 - a}}.
  $$

  The combination of these two algorithms is a fatal threat for weak key RSA cryptosystem.


\subsection{GNFS (General Number Field Sieve)}

  GNFS Algorithm is based on the bifield mapping 
  between the algebraic number field and the rational number field.
  The time complexity of GNFS is $L_n [\dfrac{1}{3}, \left( \dfrac{64}{9} \right)^{\frac{1}{3}}]$.
  From the definition of subexponential function, we can assume that GNFS performs
  better than ECM for very large scale $n$ (which is usually more than 150 bits in decimal).

  However, the engineering implementation of GNFS is very difficult, and is strongly dependent
  on distributive computing environment.

\subsection{Summary}

  Even if we use the most efficient algorithm mentioned above,
  deciphering RSA ciphertext with a key more than 2048 bits in decimal is still
  computationally infeasible.
  Though quantum algorithms like Shor's Algorithm can deal with strong key cases in polynomial time,
  the implementation of them are not yet available.

  Thus, we can assume that RSA algorithm is secure against classical attacks.
