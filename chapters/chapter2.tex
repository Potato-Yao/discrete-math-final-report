\chapter{Mathematical Foundation}

To build the RSA algorithm and verify its correctness, several fundamental mathematical tools are needed.

\section{Modular Arithmetic and the Multiplicative Group}

\begin{defn}
  If $a$ and $b$ are integers and $m$ is a positive integer, then $a$ is \textbf{congruent} to $b$ modulo $m$ if $m$ divides the difference $a - b$. We use the notation $a \equiv b \pmod{m}$ to indicate it.
\end{defn}

By the definition of congruence, we have the theorem\ref{them:0}.

\begin{them}\label{them:0}
  $a \equiv b \pmod{m} \iff \exists k \in \mathbb{Z} \text{ such that } a = b + km$.
\end{them}

Let $\mathbb{Z}_m$ be the set of all possible remainders modulo $m$, as the set $\{n \in \mathbb{Z} \mid 0 \le n < m\}$. We can define the addition and multiplication on this set, as

\begin{align*}
  a +_m b &= (a + b) \pmod{m} \\
  a \cdot_m b &= (a \cdot b) \pmod{m}
\end{align*}

These operations form the arithmetic modulo $m$. What's more, by considering the set $\{n\in \mathbb{Z}_m \ |\ \gcd{} (n, m) = 1\}$, we can form the multiplicative group of integers modulo $m$.

\begin{defn}[Multiplicative group of integers modulo $m$]
  The group $(\mathbb{Z}_m^*, \cdot_m)$ consists of the set $\mathbb{Z}_m^* = \{k \in \mathbb{Z}_m \mid \gcd(k, m) = 1\}$, with the operation $a \cdot_m b = (a \cdot b) \pmod{m}$.
\end{defn}


This group provides a closed, reversible structure, which is essential for making RSA working correctly.

\section{Greatest Common Divisor and the Extended Euclidean Algorithm}

\begin{defn}[Greatest common divisor]
  Let $a$ and $b$ be non-zero integers. The largest integer $d$ such that $d \mid a$ and $d \mid b$ is called the \textbf{greatest common divisor} of $a$ and $b$, denoted by $\gcd(a, b)$.
\end{defn}

\begin{them}[Bézout’s Identity]\label{them:1}
  Let $d = \gcd(a, b)$. Then $\exists x, y$ such that $ax + by = d$.
\end{them}

By using the Extended Euclidean Algorithm, we can not only find the greatest common divisor of two integers $a$ and $b$, but also determine the $x$ and $y$ by theorem\ref{them:1}. 

\begin{lstlisting}[caption={The Extended Euclidean Algorithm}, label={alg:eea_general}]
Algorithm: EEA(a, b)
Input: Two integers a and b
Output: A tuple (gcd, x, y) such that ax + by = gcd(a, b)

$old\_r, r \gets a, b$
$old\_s, s \gets 1, 0$
$old\_t, t \gets 0, 1$

While $r \neq 0$:
      $q \gets old\_r \text{ div } r$
      $(old\_r, r) \gets (r, old\_r - q \times r)$
      $(old\_s, s) \gets (s, old\_s - q \times s)$
      $(old\_t, t) \gets (t, old\_t - q \times t)$

Return $(old\_r, old\_s, old\_t)$
\end{lstlisting}

\section{Euler's Totient Function}

\begin{defn}[Euler's Totient Function]
  Euler's Totient Function $\varphi(n)$ counts the number of integers less than $n$ that are coprime to $n$.
\end{defn}

A useful expression for calculating this function based on the prime factorization of $n$ is given by Theorem \ref{them:2}.

\begin{them}\label{them:2}
  \begin{equation*}
    \varphi(n) = \prod_{i = 1}^r p_i^{k_i - 1}(p_i - 1)
  \end{equation*}
  where $n = p_1^{k_1}p_2^{k_2}\cdots p_r^{k_r}$.
\end{them}